JDBC : DB마다 다른 연결방식 통일한 인터페이스
java.sql.Connection - 연결
java.sql.Statement - SQL을 담은 내용
java.sql.ResultSet - SQL 요청 응답

불편한점 : JDBC 반복코드가 생김 (조회/수정/삭제시마다 반복코드), SQL은 여전히 입력해야함

JPA : DB마다 다른 SQL 사용법 문제 해결
SQL Mapper : JDBC의 반복 코드 제거, SQL 응답 결과를 객체로 편리하게 변환, SQL은 여전히 직접 입력해야함. 대표 기술: 스프링 JdbcTemplate, MyBatis
ORM : SQL 직접 작성 안해도 됨. 기술 난이도 높아서 실무에서 쓰려면 깊이 학습 필요. 대표 기술: JPA, 하이버네이트, 이클립스링크


테스트 시 예외 검증 : assertThatThrownBy 사용


---

커넥션 풀 : 커넥션 매번 새로생성시 느리고 비효율, 미리 생성해둔 커넥션풀을 DB커넥션시 꺼내쓰고 종료하지않고 반환방식
실무에선 기본으로 사용하며, 커넥션 풀 오픈소스 중 hikariCP를 주로 쓴다
DataSource : 커넥션 획득방법 추상화 하는 인터페이스 (드라이버매니저 쓰다가 커넥션풀 쓰도록 변경시 코드 변경해야함. 그래서 추상화)
- DataSource 핵심기능 : 커넥션 조회
hikariCP : 커넥션 풀링 (재사용)

트랜잭션 : 트랜잭션 하나를 위한 여러 작업 묶음
원자성/일관성/지속성 보장, 격리성은 성능에 따라 다르게 보장, 보통 커밋된 읽기 수준으로 보장
DB연결구조 : (WAS나 DB툴)커넥션->(DB내부)세션->(DB내부)트랜잭션->(DB내부)커밋 혹은 롤백

기본이 자동커밋모드임
자동커밋 끄고 수동커밋을 써야 트랜잭션을 제대로 사용할 수 있다 (set autocommit false;)

DB 락 - 여러 유저 동일 데이터 동시 수정시 꼬임 방지를 위해 먼저 온 세션에게 락을 줌
커밋이나 롤백해야 다음 유저에게 락 넘어감
다음유저가 트랜잭션 실행 시 입력한 락 타임동안 대기해도 락 얻지 못하면 오류 발생시킴

일반적으로 데이터 조회시엔 락 사용하지 않지만
조회시에도 락획득 가능 : select for update 구문사용 (커밋이나 롤백시 락 반납)

트랜잭션은 비즈니스 로직이있는 서비스 계층에서 시작해야함.
서비스[커넥션 생성 - 트랜잭션시작 - 비즈니스 로직 - (DB)업데이트 - 트랜잭션 종료 - 커넥션 종료]

트랜잭션은 하나의 커넥션 안에서 이루어져야함 -> 리포지토리 로직에서 커넥션 신규 생성부분 없이 파라미터로 커넥션 전달하는 메서드 추가생성
서비스 로지겡서 트랜잭션 시작시 오토커밋 비활성화, 종료전 커밋 시킴. 예외시 롤백 시킴. 종료시 오토커밋 다시 트루처리.

*남은문제* = 애프리케이션에서 DB트랜잭션 적용시 서비스계층 지저분해짐 -> 이후 방법으루 해결댐
트랜잭션 문제(jdbc기술 서비스계층에 누수 및 트랜잭션 적용 반복코드)
예외누수(jdbc기술 서비스계층에 누수)
jdbc반복문제(현재 리포지토리코드는 반복많음 try,catch,finally, getConnection,PreparedStatement 등)

[프레젠테이션 계층]
@Controller : UI관련 처리. 웹 요청과 응답, 사용자 요청을 검증. 주 사용기술 : 서블릿, HTTP 등 웹 기술, 스프링MVC

[서비스 계층]
@Service : 비즈니스 로직. 주 사용 기술: 가급적 특정기술의존없이 순수 자바코드로 작성

[데이터 접근 계층]
@Repository : DB 접근 처리. 주 사용 기술 : JDBC, JPA, File, Redis, Mongo ...


트랜잭션 추상화
JDBC쓰다 JPA로 변경시 서비스계층코드까지 변경필요 -> 트랜잭션 추상화 인터페이스 만들고 각 구현체 만들어서 해결
=> 스프링은 트랜잭션매니저로 이미 인터페이스와 구현체까지

 구현해두었따 PlatformTransactionManager

ThreadLocal : 트랜잭션 동기화 매니저에서 쓰레드로컬써서 멀티 쓰레드 상황에서 안전하게 커넥션 동기화한다
트랜잭션매니저는 트랜잭션시작된 커넥션을 트랜잭션 동기화 매니저에 보관
리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션 꺼내 사용하므로 파라미터로 커넥션 전달 안해도댐

사용법
커넥션 얻을때,닫을때 둘다 DataSourceUtils 사용해야함. 얻을때:getConnection, 닫을때:releaseConnection


템플릿 콜백 패턴 : 트랜잭션 반복코드 해결 (트랜잭션 시작/커밋/롤백 코드 제거)

트랜잭션 AOP : 여전히 서비스 로직 안에 트랜잭션 기술 로직 있는 문제 해결
@Transactional 써서 사용 : 트랜잭션매니저/트랜잭션템플릿 다 알아서 해줌
실무에선 99퍼 선언적 트랜잭션관리 사용(@Transactional) 


커넥션 추상화-> 데이터소스
(커넥션풀링-> hikariCP)
트랜잭션 추상화&간단히-> @Transactional

스프링부트는 데이터소스,트랜잭션매니저를 자동으로 스프링 빈에 등록해준다
(데이터소스 생성시 application.properties에 등록된 속성사용해서 등록해줌)
트랜잭션매니저는DataSourceTransactionManager와 JpaTransactionManager 동시 사용시 JPA 기본으로 등록함(DataSourceTransactionManager의 기능 거의 겹치므로)

-> 트랜잭션 프록시 (->서비스 로직) -> 리포지토리 로직

자바예외
Throwable : 최상위 예외 , 하위에 Exception과 Error가 있다
Error : 메모리 부족이나 심각한 시스템 오류같이 애플리케이션에서 복구 불가한 시스템 예외 (개발자는 이건 그냥 두면 댐)
따라 애플리케이션에선 Exception부터 잡는다 : 체크 예외
SQLException, IOException, RuntimeException
(런타임은 언체크 예외 : 컴파일러가 체크하지 않는 예외)

예외 : 잡아서 처리하거나 , 처리못하면 밖으로 던진다 , 처리하면 그 이후 단에선 로직이 정상흐름으로 동작. 처리못하면 계속 밖으로 던짐.
예외 잡거나 던질때 그 하위 예외까지 모두 처리됨.

Exception 을 상속받으면 체크 예외가 된다.
참고로 RuntimeException 을 상속받으면 언체크 예외가 된다.

체크 예외 VS 언체크 예외
체크 예외: 예외를 잡아서 처리하지 않으면 항상 throws 에 던지는 예외를 선언해야 한다.
언체크 예외: 예외를 잡아서 처리하지 않아도 throws 를 생략할 수 있다.

예외활용 - 기본적으로 언체크 예외를 활용함.
너무중요한로직 제외.

정리
처리할 수 있는 체크 예외라면 서비스나 컨트롤러에서 처리하겠지만, 지금처럼 데이터베이스나 네트워크 통신처
럼 시스템 레벨에서 올라온 예외들은 대부분 복구가 불가능하다. 그리고 실무에서 발생하는 대부분의 예외들은 이
런 시스템 예외들이다.
문제는 이런 경우에 체크 예외를 사용하면 아래에서 올라온 복구 불가능한 예외를 서비스, 컨트롤러 같은 각각의
클래스가 모두 알고 있어야 한다. 그래서 불필요한 의존관계 문제가 발생하게 된다

=>체크예외잡아서 언체크예외로 던지면댐

(중요) 예외를 전환할 때는 꼭! 기존 예외를 포함하자 (스택트레이스)

스프링의 예외 추상화 -> db마다 다른 오류코드나 수많은 예외케이스를 스프링이 정리하여 일관된 형태로 제공한다 
이를 스프링이 제공하는 예외변환기로 쉽게 사용가능하다.


SQLExceptionTranslator exTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);
DataAccessException resultEx  = exTranslator.translate("설명",sql,e);
==> 리포지토리에선 바로위 구문대신 throw exTranlator.translate("설명",sql,e); 이렇게해서 던지면댐.

JDBC반복코드 제거 : 템플릿 콜백 패턴 (JdbcTemplate 사용)
JdbcTemplate 은 JDBC로 개발할 때 발생하는 반복을 대부분 해결해준다. 그 뿐만 아니라 지금까지 학습했던, 트랜
잭션을 위한 커넥션 동기화는 물론이고, 예외 발생시 스프링 예외 변환기도 자동으로 실행해준다

생성/수정/삭제 -> template.update로 다해결
조회 -> template.queryForObject(sql, memberRowMapper(), 조회값);와 변하는 부분(memberRowMapper())에 대한 구현만 하면 해결
