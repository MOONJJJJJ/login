메서드 : 모듈화
중복 제거 : 동일 동작 하나의 메서드 호출로 중복 제거
변경 영향 범위 : 코드 변경 시 영향도 줄임
메서드 이름 추가 : 코드 파악 용이

객체지향 프로그래밍
캡슐화 : 속성+기능을 하나의 클래스에 응집

this : 인스턴스 자기자신의 참조값을 가리킴!
멤버 변수와 매개변수의 이름이 같을 경우 구분을 위해, this.변수명 사용 시 멤버 변수를 가리킴 (그냥 변수명만 쓰면 둘 다 있을 땐 매개변수를 가리킴)

생성자 : 객체를 생성한 직후 초기화를 위한 특별한 메서드
- 생성자의 이름은 클래스와 동일(대문자로 시작)
- 반환타입 없다
- 객체 생성과 동시에 초기화!
- 생성자 사용시, 초기화 안하면 컴파일 오류 발생시켜서 제약을 만들어준다 (원천적으로 버그 방지!)
- 생성자도 오버로딩 가능!
- 오버로딩 시 this() 기능 사용 시 생성자 내부에서 다른 생성자 호출 가능!
ex: MemberConstruct(String name, int age) {
        this(name, age, 50); //변경
    }
- this() 규칙 : 생성자 코드의 첫줄에만 사용 가능

기본 생성자 :
- 매개변수 없는 생성자를 기본 생성자라 함
- 클래스에 생성자가 하나도 없으면 자바 컴파일러는 기본 생성자를 자동으로 생성함
- 생성자가 하나라도 있으면 자바는 기본 생성자를 만들지 않음

패키지 : 폴더 / 클래스 : 파일
다른 패키지 사용 시 : 패키지 전체 경로 포함해서 클래스를 적어주어야 한다. (*(아스타?) 사용하여 일괄 선언 가능) -> import로 선언 시 코드에서 생략 가능! 코드 초반부에 import로 다 세팅해두쟈
*같은 이름의 클래스가 있다면, import는 둘 중 하나만 선택 가능 (자주 쓰는걸 import, 나머지는 전체경로 적어서 사용)
규칙 : 모두 소문자 사용, 패키지 이름의 앞 부분에는 일반적으로 회사의 도메인 이름을 거꾸로 사용. ex: com.company.myapp
패키지는 일반적으로 계층 구조를 이루나, 사용시엔 전부 별개의 패키지로 보고, 모두 import되어야 한다

접근 제어자 : 속성과 기능을 외부로부터 숨기는 것. 외부에서 필드나 메서드에 접근하는 것을 허용하거나 제한할 수 있따
내부 메서드에서 필드값에 대한 제약이 있을 때, 메서드를 통해서만 필드값 변경이 필요할 수 있으며, 이를 위해 필드 선언 시 접근제어자로 선언하여 접근을 제한한다
private : 모든 외부 호출 막음
default : 같은 패키지 안에서 호출 허용 (접근 제어자 안쓰면 이게 디폴트)
protected : 같은 패키지 안에서 호출 허용, 패키지 달라도 상속 관계의 호출 허용
public : 모든 외부 호출 허용

접근제어자는 필드/메서드/생성자에 사용가능, 지역변수엔 못 써

클래스 접근 제어자 : public, default만 사용 가능, public 클래스는 반드시 파일명과 동일해야함, 하나의 파일 내에 클래스 여러 개 생성 가능!!

<캡슐화>
캡슐화를 안전하게 완성하는 것 : 제어자
숨길것 : 데이터(메서드를 통해 접근해야함)/기능(외부말고 내부에서 쓰는 기능은 다숨겨)

자바 메모리 구조
메서드 영역 : 클래스 정보 보관, 붕어빵 틀
힙 영역 : 객체(인스턴스) 생성되는 영역, 붕어빵, 참고로 배열도 이 영역에 생성됨
스택 영역 : 실제 프로그램이 실행되는 영역, 메서드를 실행할 때 마다 하나씩 쌓임
단축키 컨트롤+W :

static : 공용 변수로 사용. 인스턴스가 여러개여도 static변수는 1개만 존재하며 공용으로 사용함
멤버 변수에 static을 붙이면 static 변수, 정적 변수, 클래스 변수라 한다. static 변수는 인스턴스 영역이 아닌 메서드 영역에서 관리함. (붕어빵틀에서 특별히 관리!)
클래스명.변수명으로 접근함 (바로 접근), 해당 클래스 내에선 클래스명 생략 가능
정적변수는 인스턴스를 통한 접근도 가능하고(권장안함), 클래스를 통한 접근도 가능함 (객체명.변수명, 클래스명.변수명)

static 메서드 : 메서드에 static 붙이면, 객체 생성 없이 클래스명.메서드 명으로 바로 호출가능
static 메서드는 static 변수나 static 메서드만 사용가능함. 인스턴스 변수나 메서드를 static 메서드 내에서 사용 불가. 모든 곳에서 static 메서드 호출 가능함.
(정적 메서드는 객체 생성없어도 사용가능하므로, 인스턴스 변수/메서드 사용 불가함)
*외부에서 참조값 넘어오는 경우(매개변수 전달)는 정적 메서드에서도 인스턴스 값 호출 가능

import static : 선언시 클래스명 안적어도 메서드만으로 static 메서드 호출가능 , static 변수도 마찬가지

main()은 정적메서드이고, 정적메서드는 정적메서드만 호출 가능하므로, main 내에서는 정적 메서드만 호출가능!

클래스 내에서 private 생성자 선언 : 인스턴스 생성을 막는다 -> static 메서드만 사용하는 클래스의 경우 이렇게 제약을 준다.

final 변수 : 최초 1회만 값 할당 가능, 파라미터로 사용 시 메서드 내부에서 값 못 바꿈
=> 클래스의 멤버변수를 final로 쓸 때, 필드영역에서 바로 값 할당하는 경우(상수), final 만 쓰지말고 (인스턴스마다 같은 값으로 생성되므로 메모리 낭비) static final로 한 번 만 생성되게 하여 상수로 사용
static final 변수 : 상수로 사용, 상수는 변수명 전체 대문자를 쓰고, 구분은 언더바_로 함

참조형에 final을 걸 경우 : 참조값만 못 바꾸고, 해당 주소의 value값은 변경 가능

상속 - 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용
부모 클래스 (슈퍼 클래스) , 자식 클래스 (서브 클래스) : 부모의 기능을 자식이 물려받음. 부모는 자식의 기능에 접근 불가
클래스 생성 시 "extends 부모클래스명"으로 상속
다중 상속 불가 (각 부모 클래스 내 동명 메소드 존재할 수 있으므로) - 부모여럿불가, 자식여럿가능
(인터페이스로는 다중 구현 허용)
상속 시 메모리 구조 : 하나의 참조값 안에 부모 공간 자식 공간 나뉘어서 전부 생성 됨 (내부적으로 부모와 자식 다생긴다)
호출 시 자식에 없으면 부모에 가서 찾음 (자식 먼저)
상속과 기능 추가 : 부모에만 기능 추가 시 자식이 다 갖다 쓸 수 있음! 확장 용이!

오버라이딩 : 부모의 기능을 자식이 새로 재정의 하는 것. 이름 같지만 새로운 기능 사용할 때! @Override로 자식클래스에서 재정의함
@ : 애노테이션, 프로그램이 읽을 수 있는 특별한 주석!
@Override 자체는 필수아니지만, 제대로 재정의안될때 컴파일 오류 발생시켜주므로 권장!

오버로딩 : 메서드 이름같고 파라미터 다른 메서드 여러개 정의하는 것
오버라이딩 : 하위 클래스에서 상위 클래스의 메서드 재정의 하는 것. 상속 관계에서 사용.

오버라이딩 조건 : 메서드 이름 같아야함 / 파라미터 타입/순서/개수 같아야함 / 반환타입 같아야함 / 접근 제어자는 상위보다 제한적이면 안됨. 하위가 똑같거나 더 열려있어야댐.
static, final, private 붙이면 오버라이딩 불가능!
생성자 오버라이딩 불가능!
하위는 상위 메서드보다 더 많은 체크 예외를 throws로 선언 불가!

super : 오버라이딩 된 값의 부모 값을 참조하고 싶을때 사용

*상속 관계 사용시 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다!!
첫줄에 super(); (기본 생성자(파라미터 없는)는 이 구문 생략 가능)
부모가 기본생성자가 없으면 직접 super(파라미터);로 생성해줘야 한다. (생성자 하나라도 존재시 기본생성자 안 생김)
예외로, this() 생성자를 첫줄에 사용가능하나(super없이), super()도 반드시 타고타고가서 나오는 어떤생성자 안에서든 언젠가는 생성해야한다

상속 => 공통적인 부분은 부모에서, 개별적인 부분은 자식에서 관리! 기능 확장에도 용이!

다형성 : 여러형태 , 하나의 객체가 여러타입으로 사용가능. 핵심 : 부모는 자식을 품을 수 있따!
부모는 자식, 손자 인스턴스를 담을 수 있다. 자식은 부모 인스턴스를 담을 수 없다.
그치만 자식의 기능을 호출할 수 없다.
부모객체 변수 = new 자식객체();
부모객체 변수 = 자식변수;

다운캐스팅 : 자식에서 부모 담음. 자식의 기능 호출 필요시 사용.
자식객체 변수 = "(자식객체)" 부모변수
(주의) 부모변수 자체가 자식객체로 변하지않음. 참조값을 자식변수에 넣는것.

일시적 다운캐스팅하여 자식 기능 호출법 (연산자 우선순위때매 괄호 텍스트 포함 필수!)
((자식객체) 부모변수).자식메서드

업캐스팅 : 부모에 자식 담음 (생략권장, 어짜피 됨)
부모객체 변수 = "(부모객체)" 자식변수 -> 어짜피 되므로 "(부모객체)" 생략함

업캐스팅 안전/다운캐스팅 위험 이유
객체생성시 상위부모타입은 함께 생성됨
따라서 위로만 타입변경하는 업캐스팅은 메모리상에 인스턴스 모두 존재하므로 항상 안전.
다운캐스팅은 반대. 위험.
이유 - 같은 부모객체여도 자식을 참조(다형적 참조)하는 객체가 있고, 아닌 경우가 있을 수 있는데, 아닌경우엔 다운캐스팅 시 런타임에러(ClassCastException) 발생 하므로!

instanceof : 변수가 참조하는 인스턴스 타입 확인. 객체는 자식/손자도 참조할 수 있으므로, instanceof를 통해 원하는 타입으로 변경이 가능한지 확인 후 다운캐스팅 수행하도록 해줌 (안전도 상승!)
(주의) 왼쪽에서 오른쪽에서 참조하는경우 true 뜸 (child instanceof parent = true임)
자바16부터는 instaceof쓰면서 동시에 변수 선언 가능: instaceof 객체명 변수명  (바로 다운캐스팅 가능 - 변수명.메서드)

다형적 참조 (부모가 자식품음) 시, 최하위 자식의 오버라이딩 메서드가 우선권 가진다! (최하위 자식 메서드로 호출됨) 부모<자식<손자

다형성 핵심 : 다형적 참조 + 메서드 오버라이딩
==> 각각의 요소가 모두 같은 타입을 사용하고, 각자 자신의 메서드도 호출 가능함.

변하는 부분과 변하지 않는 부분 명확히 나누고, 변경 발생 시 변하는 부분 최소화 하는 것이 좋은 코드

추상클래스 : 추상적개념을 제공하는 클래스로, 실체인 인스턴스 존재하지않으며 대신 상속을 목적으로 사용되는 부모 클래스의 역할을 담당
abstract class 클래스명()
인스턴스 생성 못하는 제약이 있음
=> 실수로 인스턴스를 생성할 이슈를 근본적으로 방지해준다. 

추상메서드 : 추상적개념 제공하는 메서드로, 반드시 오버라이드 해서 사용해야하는 메서드! 오버라이딩 하지 않으면 자식도 추상클래스가 되어야함!
추상메서드가 하나라도있으면 추상클래스로 선언해야함! 
=> 오버라이드해서 써야하는 메서드를 오버라이드 하지 않을 이슈를 근본적으로 방지해준다.
 
순수 추상 클래스 : 모든 메서드가 추상 메서드인 추상 클래스 => 코드를 실행할 바디 부분이 전혀 없다.
인스턴스 생성 불가 / 상속시 모든 메서드 오버라이딩 해야댐 / 주로 다형성을 위해 사용
==> 규격에 맞춰 구현할 수 있다!

인터페이스=순수 추상 클래스+약간의 편의기능 , class대신 interface로 사용. 인터페이스를 상속할땐 extends 대신 implements 사용.
인터페이스의 메서드는 모두 public, abstract 이다.
메서드에 public, abstract 생략가능 (생략이 권장됨)
다중 구현(다중 상속) 지원함
인터페이스에서 멤버변수는 public, static, final이 모두 포함되어있다고 간주되며 생략 권장됨. 상수임
인터페이스의 상속은 구현이라 표현함. 인터페이스의 구현관계는 UML에서 점선 사용 (클래스의 상속관계는 UML에서 실선 사용)
(상속은 부모껄 물려받는데, 구현은 하나하나 다 자식에서 구현해야하는 차이)

인터페이스 쓰는 이유 : 
1.제약 : 모든 메서드가 추상메서드이므로 제약이 생긴다 (규격맞게 구현가능) 
2. 다중 구현 : 다중 구현(부모 여럿 가능)

다중구현 가능이유 : 인터페이스는 모두 추상메서드이고, 실제 기능구현은 자식에서 하므로 다이아몬드 문제 발생 안함

좋은 객체 지향 프로그래밍 : 다형성이 젤 중요!
"역할"과 "구현"으로 구분하면 세상이 "단순"해지고, "유연"해지며 "변경"도 편해진다
클라이언트는 대상의 "역할"만 알면 된다
클라이언트는 구현 대상의 내부구조를 몰라도 되고, 구현 대상의 내부 구조가 변경되어도 영향이 없고, 구현 대상 자체를 변경해도 영향받지 않는다.
역할=인터페이스
구현=인터페이스를 구현한 클래스, 구현 객체
객체의 협력이라는 관계부터 생각
클라이언트 : 요청 , 서버 : 응답
수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다
클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다 

디자인 패턴 대부분은 다형성을 활용하는 것

OCP 원칙! Open-Closed Principle
확장은 열려있고, 코드 수정은 닫혀있따
변하지 않는 부분 : 클라이언트 코드
전략패턴! 디자인 패턴의 하나로, 클라이언트 수정 없이 교체 가능한 패턴